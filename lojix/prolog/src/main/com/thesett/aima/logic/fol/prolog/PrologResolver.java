/*
 * Copyright The Sett Ltd, 2005 to 2014.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.thesett.aima.logic.fol.prolog;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;

import com.thesett.aima.logic.fol.Clause;
import com.thesett.aima.logic.fol.Functor;
import com.thesett.aima.logic.fol.Resolver;
import com.thesett.aima.logic.fol.Term;
import com.thesett.aima.logic.fol.TermUtils;
import com.thesett.aima.logic.fol.Variable;
import com.thesett.aima.logic.fol.VariableAndFunctorInterner;
import com.thesett.aima.logic.fol.prolog.builtins.BuiltIn;
import com.thesett.aima.logic.fol.prolog.builtins.BuiltInFunctor;
import com.thesett.aima.logic.fol.prolog.builtins.BuiltInTransform;
import com.thesett.aima.logic.fol.prolog.builtins.DefaultBuiltIn;
import com.thesett.aima.logic.fol.prolog.builtins.FirstStepBuiltIn;
import com.thesett.aima.logic.fol.prolog.builtins.PrologUnifier;
import com.thesett.aima.logic.fol.prolog.builtins.ResolutionState;
import com.thesett.aima.search.GoalState;
import com.thesett.aima.search.Operator;
import com.thesett.aima.search.QueueBasedSearchMethod;
import com.thesett.aima.search.RepeatedStateFilter;
import com.thesett.aima.search.SearchNode;
import com.thesett.aima.search.SearchNotExhaustiveException;
import com.thesett.aima.search.Traversable;
import com.thesett.aima.search.TraversableState;
import com.thesett.aima.search.util.OperatorImpl;
import com.thesett.aima.search.util.Searches;
import com.thesett.aima.search.util.backtracking.DepthFirstBacktrackingSearch;
import com.thesett.aima.search.util.backtracking.ReTraversable;
import com.thesett.common.util.EmptyIterator;
import com.thesett.common.util.Filterator;
import com.thesett.common.util.Function;
import com.thesett.common.util.SimpleQueue;
import com.thesett.common.util.Sink;
import com.thesett.common.util.StackQueue;
import com.thesett.common.util.logic.UnaryPredicate;

/**
 * PrologResolver implements the prolog resolution procedure over horn clauses. This consists of unifying query functors
 * against the available clauses, in the order that they are presented.
 *
 * <p/>Resolution is effectively the process of turning queries into variable bindings that resolve the query against
 * the domain. When a matching clause is found, every functor in its body is added to a stack of queries to be resolved,
 * or if it has no body a match is returned immediately. The process continues until the stack of queries to resolve has
 * been exhausted with succesfull bindings.
 *
 * <p/>This Prolog resolution procedure is built on top of a {@link DepthFirstBacktrackingSearch}. The current search
 * state consists of the domain and the query stack with in-place variable bindings. The operators to produce new search
 * states consists of the possible clause heads in the domain that can be unified with the current head of the query
 * stack. When the back-tracking search establishes a search state, the unification of the current query head and the
 * clause head leading to that state takes place. The variable bindings generated by this unification, if any, are
 * noted, so that if the search has to back-track over the state the bindings can be undone. In this implementation, the
 * variable bindings take place directly in the domain and query clauses, so only one path of enquiry, from the root of
 * the query to the current search state, may have its bindings active at any one time. This is guaranteed because the
 * default {@link DepthFirstBacktrackingSearch} uses a depth first ordering, which is the standard ordering for
 * evaluating Prolog.
 *
 * <pre><p/><table id="crc"><caption>CRC Card</caption>
 * <tr><th> Responsibilities <th> Collaborations
 * <tr><td> Resolve a query over a set of Horn clauses.
 *     <td> {@link PrologUnifier}, {@link QueueBasedSearchMethod}, {@link DepthFirstBacktrackingSearch}
 * </table></pre>
 *
 * @author Rupert Smith
 * @todo   How it works. Query on goal. Take possibly matching clause. Attach stack frame to clause. Unify with clause
 *         bindings are placed in the stack frame, clause remains clean and can be re-used. Right hand side of clause
 *         added to goal stack, using 'query conversion'. Goal stack is a stack so unification proceeds depth first,
 *         left-to-right. Default variable/variable binding direction is downwards? Upon back-tracking variable bindings
 *         are undone and the goal stack is restored to its prior state.
 */
public class PrologResolver extends PrologUnifier implements Resolver<PrologCompiledClause, PrologCompiledClause>,
    QueueBasedSearchMethod<ResolutionState, ResolutionState>, Cloneable
{
    /** Used for providing user readable execution traces. */
    /* private static final Logger trace = Logger.getLogger("TRACE.Prolog." + PrologResolver.class.getSimpleName()); */

    /** Flag used as a quick check to see if trace is enabled. */
    private static final boolean TRACE = false; //log.isLoggable(Level.FINE)

    /** Holds the built-in transform function to create built-ins for functors. */
    private static BuiltInTransform builtInTransform;

    /** Holds the indenter to provide neatly indented execution traces. */
    //protected TraceIndenter indenter = new TraceIndenter(true);

    /** Holds the search over the resolution space. */
    protected QueueBasedSearchMethod<ResolutionState, ResolutionState> resolutionSearch =
        new DepthFirstBacktrackingSearch<ResolutionState, ResolutionState>();

    /** Holds the domain being queried over. */
    //protected List<PrologCompiledClause> domain = new LinkedList<PrologCompiledClause>();
    protected Map<Integer, List<PrologCompiledClause>> domain = new HashMap<Integer, List<PrologCompiledClause>>();

    /** Holds the current query if one has been set. */
    protected Clause currentQuery;

    /** Holds the stack of query functors remaining to be resolved. */
    protected Queue<BuiltInFunctor> goalStack;

    /** Holds a list of all variable bindings required to satisfy the most recent query. */
    protected StackQueue<Variable> bindings;

    /** Holds the symbol table for translating interned names, mainly for debugging purposes. */
    protected VariableAndFunctorInterner interner;

    /**
     * Creates a new Prolog resolution engine.
     *
     * @param interner The symbol table for translating interned names, to provide readable debugging output.
     */
    public PrologResolver(VariableAndFunctorInterner interner)
    {
        this.interner = interner;
        builtInTransform = new BuiltInTransform(interner);
    }

    /** {@inheritDoc} */
    public void addToDomain(PrologCompiledClause term)
    {
        List<PrologCompiledClause> predicate = domain.get(term.getHead().getName());

        if (predicate == null)
        {
            predicate = new LinkedList<PrologCompiledClause>();
            domain.put(term.getHead().getName(), predicate);
        }

        predicate.add(term);
    }

    /** {@inheritDoc} */
    public void setQuery(PrologCompiledClause query)
    {
        // Reset the search in order to initialize it.
        resolutionSearch.reset();

        // Keep a reference to the current query.
        currentQuery = query;

        // Create the starting point for the resolution, consisting of the queries to resolve as the intial goal stack,
        // and an empty list of bindings.
        goalStack = new StackQueue<BuiltInFunctor>();

        // Create a fresh list to hold the results of the resolution in.
        bindings = new StackQueue<Variable>();

        // Create the initial state of the proof search.
        ResolutionState initialState = new ResolutionStateImpl(query);
        addStartState(initialState);

        // If printing execution traces, ensure the execution indenter starts from zero.
        /*if (TRACE)
        {
            indenter.reset();
        }*/
    }

    /** {@inheritDoc} */
    public Set<Variable> resolve()
    {
        // Find all free variables in the query.
        Set<Variable> freeVars = TermUtils.findFreeNonAnonymousVariables(currentQuery);

        // Used to collect the results in.
        Set<Variable> results = null;

        // Search for the next available solution.
        SearchNode solution;

        try
        {
            solution = findGoalPath();
        }
        catch (SearchNotExhaustiveException e)
        {
            // The search may fail if the maximum number of search steps is reached. This limit is not turned on by
            // default. If this happens, null is returned, indicating that no solution was found.
            // Exception ignored as empty search results are noted and dealt with by returning null.
            e = null;
            solution = null;
            results = null;
        }

        // Check that a solution was found and return the variable bindings from it if so. Only the variable bindings
        // that were free and non-anonymous in the original query are returned.
        if (solution != null)
        {
            results = new HashSet<Variable>(freeVars);
        }

        return results;
    }

    /** {@inheritDoc} */
    public void setMaxSteps(int max)
    {
        resolutionSearch.setMaxSteps(max);
    }

    /** {@inheritDoc} */
    public void addStartState(ResolutionState startState)
    {
        resolutionSearch.addStartState(startState);
    }

    /**
     * {@inheritDoc}
     *
     * <p/>This implementation defines its own goal predicate that cannot be replaced. Calling this method will always
     * results in an UnsupportedOperationException.
     */
    public void setGoalPredicate(UnaryPredicate<ResolutionState> goalPredicate) throws UnsupportedOperationException
    {
        throw new UnsupportedOperationException();
    }

    /**
     * {@inheritDoc}
     *
     * <p/>This also resets the entire knowledge base of this resolver, so that it is empty.
     */
    public void reset()
    {
        // Empty the knowledge base and clear the current query.
        domain = new HashMap<Integer, List<PrologCompiledClause>>();
        currentQuery = null;

        // Reset the underlying search.
        resolutionSearch.reset();

        // If printing execution traces, ensure the execution indenter starts from zero.
        /*if (TRACE)
        {
            indenter.reset();
        }*/
    }

    /** {@inheritDoc} */
    public SearchNode<ResolutionState, ResolutionState> findGoalPath() throws SearchNotExhaustiveException
    {
        return resolutionSearch.findGoalPath();
    }

    /** {@inheritDoc} */
    public ResolutionState search() throws SearchNotExhaustiveException
    {
        SearchNode<ResolutionState, ResolutionState> path = findGoalPath();

        if (path != null)
        {
            return path.getState();
        }
        else
        {
            return null;
        }
    }

    /**
     * {@inheritDoc}
     *
     * <p/>This implementation does not support repeated state filters, so calling this method will always result in an
     * UnsupportedOperationException.
     */
    public void setRepeatedStateFilter(RepeatedStateFilter filter)
    {
        throw new UnsupportedOperationException();
    }

    /** {@inheritDoc} */
    public Iterator<Set<Variable>> iterator()
    {
        // Find all free variables in the query.
        final Set<Variable> freeVars = TermUtils.findFreeNonAnonymousVariables(currentQuery);

        Function<ResolutionState, Set<Variable>> listFunction =
            new Function<ResolutionState, Set<Variable>>()
            {
                public Set<Variable> apply(ResolutionState state)
                {
                    return freeVars;
                }
            };

        return new Filterator<ResolutionState, Set<Variable>>(Searches.allSolutions(this), listFunction);
    }

    /**
     * Prints the contents of this resolver as a string, mainly for debugging purposes.
     *
     * @return The contents of this resolver as a string.
     */
    public String toString()
    {
        return "PrologResolver: [ domain = " + domain + ", currentQuery = " + currentQuery + ", goalStack = " +
            goalStack + ", bindings = " + bindings + " ]";
    }

    /**
     * ResolutionStateImpl models the state space of resolution of a list of queries over a domain. The state space
     * maintains a list of variable bindings, that is built up as queries are matched onto the domain. The queries
     * themselves, form a conjunction of query functors, possibly containing variables, that are to be successively
     * matched against the domain. A state with query functors in it may lead to a statPe with a query removed and
     * replaced by variable bindings that resolve the removed query functor against the domain. A state with no
     * remaining query functors in it, and variable bindings only, has been fully resolved and is a goal state.
     */
    public class ResolutionStateImpl extends TraversableState<ResolutionState> implements GoalState,
        ReTraversable<ResolutionState>, ResolutionState
    {
        /** Holds the clause acting as the choice point that immediately led to this state. */
        private PrologCompiledClause pendingClause;

        /** Holds the resulting from the proof step that immediately led to this state. */
        private BuiltInFunctor pendingGoal;

        /** Holds the parent state that is the most recent choice point that led to this state. */
        private ResolutionStateImpl lastChoicePoint;

        /** Used to indicate whether or not this state has failed to unify with its operator clause. */
        boolean failed;

        /** Holds the stack for this states bound variables. */
        private VariableBindingStackFrame stackFrame;

        /** Holds a state local view of the goal stack, which tracks and can undo goals added by this state. */
        private GoalStack localGoalStack = new GoalStack(goalStack);

        /**
         * Holds a state local view of the variable bindings, which tracks and can undo bindings added by this state.
         */
        private BindingSink localBindings = new BindingSink(bindings);

        /** Used to hold the choice points generated by this state. */
        private Queue<ResolutionState> choicePoints = new StackQueue<ResolutionState>();

        /** Flag used to indicate that this is the first step in a proof. */
        private boolean firstStep;

        /** Flag used to indicate that this state has been cut and should fail. */
        private boolean isCut;

        /**
         * Builds a new resolution start state.
         *
         * @param pendingClause The initial query clause to start the resolution from.
         */
        public ResolutionStateImpl(PrologCompiledClause pendingClause)
        {
            this.pendingClause = pendingClause;
            firstStep = true;
        }

        /**
         * Creates a new resolution state on a new clause or goal. If the state is being set up on a new clause, then
         * the clause will be prepared to unify against when the state is established by the {@link #applyOperator()}
         * method. If the state is being set up on a new goal, then the new goal will be added to the goal queue when
         * the state is established.
         *
         * @param pendingClause   The pending clause to set up for unification when this state is established.
         * @param pendingGoal     The pending goal to add to the goal queue when this state is established.
         * @param lastChoicePoint The parent state that is the most recent choice point that led to this state.
         */
        protected ResolutionStateImpl(PrologCompiledClause pendingClause, BuiltInFunctor pendingGoal,
            PrologResolver.ResolutionStateImpl lastChoicePoint)
        {
            this.pendingClause = pendingClause;
            this.pendingGoal = pendingGoal;
            this.lastChoicePoint = lastChoicePoint;
        }

        /**
         * {@inheritDoc}
         *
         * <p/>When a state contains no queries to resolve, it is a goal state.
         */
        public boolean isGoal()
        {
            boolean isGoal = !failed && goalStack.isEmpty() && choicePoints.isEmpty();

            if (TRACE)
            {
                if (isGoal)
                {
                    /*trace.fine(indenter.generateTraceIndent() +
                        "Goal stack is empty and local choice points is empty, success!");*/
                }
                else if (failed)
                {
                    /*trace.fine(indenter.generateTraceIndent() + "Failed.");*/
                }
            }

            return isGoal;
        }

        /** {@inheritDoc} */
        public Traversable<ResolutionState> getChildStateForOperator(Operator<ResolutionState> op)
        {
            return op.getOp();
        }

        /** {@inheritDoc} */
        public float costOf(Operator op)
        {
            return 1;
        }

        /** {@inheritDoc} */
        public Iterator<Operator<ResolutionState>> validOperators(boolean reverse)
        {
            if (!failed && !choicePoints.isEmpty())
            {
                return new Filterator<ResolutionState, Operator<ResolutionState>>(choicePoints.iterator(),
                    new Function<ResolutionState, Operator<ResolutionState>>()
                    {
                        public Operator<ResolutionState> apply(ResolutionState resolutionState)
                        {
                            return new OperatorImpl<ResolutionState>(resolutionState);
                        }
                    });

            }
            else
            {
                return new EmptyIterator<Operator<ResolutionState>>();
            }
        }

        /** {@inheritDoc} */
        public void applyOperator()
        {
            // Do not establish this state if it has been cut, just fail immediately in that case.
            if (isCut)
            {
                failed = true;

                return;
            }

            // Always boost the trace indent on entering a new state.
            //indenter.generateTraceIndent(1);

            // Used to hold the original choice point clause that led to this state, so that it retained and cleaned
            // up at the end of this method, when the 'choicePointClause' field has been overwritten with the
            // query converted version.
            PrologCompiledClause originalClause = null;

            // The clause that is the choice point that led to this state needs to be 'query converted' before it can
            // be unified against, to ensure that its variables take on fresh storage slots in the stack frame for
            // this choice.
            if ((pendingClause != null) && !firstStep)
            {
                if (TRACE)
                {
                    /*trace.fine(indenter.generateTraceIndent() + "Consume choice point, " +
                        pendingClause.toString(interner, true, true) + ".");*/
                }

                // Keep a reference to the domain clause to be query converted, so that it can be cleaned up.
                originalClause = pendingClause;

                // Set up a stack frame to hold the clauses variable bindings in.
                stackFrame = new VariableBindingStackFrame(pendingClause.getStackSize());
                pendingClause.setBindingContext(stackFrame);

                // Perform query conversion on the clause to match against, to ensure that its stack variable are replaced
                // with their now allocated storage cells on the stack.
                pendingClause = (PrologCompiledClause) pendingClause.queryConversion();
            }

            // If a choice point goal led to this state, the new goal is now added to the state.
            if (pendingGoal != null)
            {
                localGoalStack.offer(pendingGoal);
            }

            // Select which built in operator is the correct one to apply to the current head goal.
            BuiltInFunctor headGoal = localGoalStack.peek();

            // Work out which built-in operator implements the head goal functor, using the default if no specialized
            // built-in is required. On the first proof step, the specail first-step built-in is always used.
            BuiltIn operation;

            if (firstStep)
            {
                operation = new FirstStepBuiltIn();
            }
            else
            {
                operation = headGoal;
            }

            // Attempt to prove the head goal. This operation should consume the goal if it is succesfull, and may
            // create more goals, variable bindings and lead to more choice points to explore.
            failed = !operation.proofStep(this);

            // Check if the successfully proved goal generated any more choice points.
            if (!failed)
            {
                operation.createContinuationStates(this);
            }

            // If the clause that is the choice point that led to this state was query converted to use this states
            // stack frame, clear that storage context from it now as it is no longer needed.
            if (originalClause != null)
            {
                // Clear the stack frame context from the domain clause, so that the clause is clear for re-use.
                // This also removes this states stack frame from being referenced by a domain clause allowing it
                // to be garbage collected.
                originalClause.setBindingContext(null);
            }
        }

        /**
         * {@inheritDoc}
         *
         * <p/>Unbinds variables bound in the query and in the stack frame, and restores the goal stack to its initial
         * state upon entry to this state.
         */
        public void undoOperator()
        {
            // Unbind variables bound by the unification of this states query goal with the possibly matching clause.
            // These bindings are the ones on the query side of the unification.
            localBindings.undo();

            // Unbind variables bound by the unification of this states query goal with the possibly matching clause.
            // These bindings are the ones on the clause side of the unification.
            if (stackFrame != null)
            {
                stackFrame.free();
                stackFrame = null;
            }

            // Restore the goal stack to where it was before this states operator was applied. Sub-goals added to the
            // stack are removed. The goal functors consumed by this state are placed back onto the goal stack.
            localGoalStack.undo();

            // Null out everything this state refers to, to assist/allow garbage collection.
            pendingClause = null;
            pendingGoal = null;
            lastChoicePoint = null;
            stackFrame = null;
            localGoalStack = null;
            localBindings = null;
            choicePoints = null;

            // Always reduce the trace indent on backing out of a state.
            //indenter.generateTraceIndent(-1);
        }

        /** {@inheritDoc} */
        public SimpleQueue<BuiltInFunctor> getGoalStack()
        {
            return localGoalStack;
        }

        /** {@inheritDoc} */
        public Sink<Variable> getVariableBindings()
        {
            return localBindings;
        }

        /** {@inheritDoc} */
        public Function<Functor, BuiltInFunctor> getBuiltInTransform()
        {
            return builtInTransform;
        }

        /** {@inheritDoc} */
        public ResolutionStateImpl getLastChoicePoint()
        {
            return lastChoicePoint;
        }

        /** {@inheritDoc} */
        public void cut()
        {
            isCut = true;
        }

        /** {@inheritDoc} */
        public Queue<ResolutionState> getChoicePoints()
        {
            return choicePoints;
        }

        /** {@inheritDoc} */
        public Clause getCurrentClause()
        {
            return pendingClause;
        }

        /** {@inheritDoc} */
        public PrologUnifier getUnifier()
        {
            return PrologResolver.this;
        }

        /** {@inheritDoc} */
        public VariableAndFunctorInterner getInterner()
        {
            return interner;
        }

        /** {@inheritDoc} */
        public void createContinuationStatesForGoal(BuiltInFunctor goal)
        {
            if (goal != null)
            {
                if (goal instanceof DefaultBuiltIn)
                {
                    List<PrologCompiledClause> predicate = domain.get(goal.getFunctor().getName());

                    if (predicate != null)
                    {
                        for (Clause clause : predicate)
                        {
                            // Perform argument matching on the first three arguments to rule out unnecessary
                            // choice point creations.
                            boolean match = argumentMatch(goal, clause, 0);

                            if (match)
                            {
                                match = argumentMatch(goal, clause, 1);
                            }

                            if (match)
                            {
                                match = argumentMatch(goal, clause, 2);
                            }

                            if (match)
                            {
                                ResolutionState newState =
                                    new ResolutionStateImpl((PrologCompiledClause) clause, null, this);

                                if (TRACE)
                                {
                                    /*trace.fine(indenter.generateTraceIndent() + "Produce choice point, " +
                                        clause.toString(interner, true, true) + ".");*/
                                }

                                choicePoints.offer(newState);
                            }
                        }
                    }
                }
                else
                {
                    getGoalStack().poll();

                    if (TRACE)
                    {
                        /*trace.fine(indenter.generateTraceIndent() + "Produce new state for goal, " +
                            goal.getFunctor().toString(interner, true, true) + ".");*/
                    }

                    choicePoints.offer(new ResolutionStateImpl(null, goal, lastChoicePoint));
                }
            }
        }

        /** {@inheritDoc} */
        /*public TraceIndenter getTraceIndenter()
        {
            return indenter;
        }*/

        /**
         * Prints this state as a string, mainly for debugging purposes.
         *
         * @return This state as a string.
         */
        public String toString()
        {
            return "ResolutionStateImpl: [ choicePointClause = " + pendingClause + ", failed = " + failed +
                ", stackFrame = " + stackFrame + ", localGoalStack = " + localGoalStack + ", localBindings = " +
                localBindings + " ]";
        }

        /**
         * Matches the specified argument of a goal functor against the head of a clause to see if they may potentially
         * unify. If the goal argument is a free variable, or the clause head argument is, they may unify with anything
         * so the result will always be true. If the arguments are functors they are matched by their interned names to
         * see if a potential unfication is going to be possible.
         *
         * @param  goal   The goal functor to match.
         * @param  clause The clause to match the head of.
         * @param  index  The index of the argument to match.
         *
         * @return <tt>true</tt> if the goal may potentially match against the head of the clause, <tt>false</tt> if it
         *         definitely will not.
         */
        private boolean argumentMatch(BuiltInFunctor goal, Clause clause, int index)
        {
            boolean match = false;

            Term firstGoalArg = goal.getFunctor().getArgument(index);
            Term firstClauseArg = clause.getHead().getArgument(index);

            if ((firstGoalArg != null) && (firstClauseArg != null) && (firstGoalArg.getValue() instanceof Functor))
            {
                if (firstClauseArg instanceof Variable)
                {
                    match = true;
                }
                else if (((Functor) firstGoalArg.getValue()).getName() == ((Functor) firstClauseArg).getName())
                {
                    match = true;
                }
            }
            else
            {
                match = true;
            }

            return match;
        }
    }

    /**
     * GoalStack provides a state local view onto a global goal stack. This view provides a local {@link #undo()}
     * operation, that resets the global goal stack to its state at the point in time when this local view was created.
     * As goals are inserted onto the stack, the number of inserted goals is tracked. When goals are consumed from the
     * stack, the consumed goals are kept and the number consumed is counted. Whenever the state of the stack changes
     * from between adding and removing goals, a fresh count is begun with the old count pushed down into a stack. The
     * undo operation removes all added or removed counts from the stack, removing the number of goals added to the
     * stack, or re-inserting the number of goals consumed from the stack. In this way arbitrary sequences of pushes and
     * pops on the stack can be undone.
     */
    private class GoalStack implements SimpleQueue<BuiltInFunctor>
    {
        /** The goal stack to provide a local view onto. */
        private final Queue<BuiltInFunctor> goalStack;

        /** Used to hold any goals consumed by this state, so that they can be restored on undo. */
        private final Queue<BuiltInFunctor> consumedGoals = new StackQueue<BuiltInFunctor>();

        /** Flag used to indicate what state this undo stack is in, if goals are being added or removed. */
        private boolean isGrowing;

        /** Flag used to indicate when the first push or pop on this stack is called to set up the first count. */
        private boolean firstCall = true;

        /** Used to record how many goals this state added, so that they can be removed upon undo. */
        private final Queue<Integer> goalsAddedCountStack = new StackQueue<Integer>();

        /** Used to record how many goals this state consumed, so that they can be removed upon undo. */
        private final Queue<Integer> goalsConsumedCountStack = new StackQueue<Integer>();

        /**
         * Creates a state local view onto a global goal stack.
         *
         * @param goalStack The goal stack to view.
         */
        public GoalStack(Queue<BuiltInFunctor> goalStack)
        {
            this.goalStack = goalStack;

        }

        /**
         * Adds a goal to the stack, tracking how many have been added.
         *
         * @param  goal The goal to add.
         *
         * @return <tt>true</tt> if the goal was added, <tt>false</tt> otherwise.
         */
        public boolean offer(BuiltInFunctor goal)
        {
            boolean result = goalStack.offer(goal);

            if (result)
            {
                if (!isGrowing || firstCall)
                {
                    goalsAddedCountStack.offer(0);
                    firstCall = false;
                }

                int goalsAdded = goalsAddedCountStack.poll();
                goalsAddedCountStack.offer(goalsAdded + 1);
                isGrowing = true;
            }

            if (result && TRACE)
            {
                /*trace.fine(indenter.generateTraceIndent() + "Push goal " + goal + ".");*/
            }

            return result;
        }

        /**
         * Consumes a goal from the stack, locally retaining the consumed goal, so that it may be placed back onto the
         * stack when the {@link #undo()} operation is invoked.
         *
         * @return The head goal on the stack, or <tt>null</tt> if there is none.
         */
        public BuiltInFunctor poll()
        {
            BuiltInFunctor result = goalStack.poll();

            if (result != null)
            {
                if (isGrowing || firstCall)
                {
                    goalsConsumedCountStack.offer(0);
                    firstCall = false;
                }

                consumedGoals.offer(result);

                int goalsConsumed = goalsConsumedCountStack.poll();
                goalsConsumedCountStack.offer(goalsConsumed + 1);
                isGrowing = false;
            }

            if ((result != null) && TRACE)
            {
                /*trace.fine(indenter.generateTraceIndent() + "Pop goal " + result + ".");*/
            }

            return result;
        }

        /**
         * Retrieves, but does not remove, the head of this queue, returning <tt>null</tt> if this queue is empty.
         *
         * @return The head of this queue, or <tt>null</tt> if this queue is empty.
         */
        public BuiltInFunctor peek()
        {
            return goalStack.peek();
        }

        /**
         * Removes the number of added goals from the stack, and places consumed goals back onto the stack. This
         * operation resets the goal stack to its state prior to this local view being established.
         */
        private void undo()
        {
            // Restore the goal stack to where it was before this states operator was applied. Sub-goals added to
            // the stack are removed. The goal functor consumed by this state is placed back onto the goal stack.
            while (!goalsAddedCountStack.isEmpty() || !goalsConsumedCountStack.isEmpty())
            {
                if (isGrowing && !goalsAddedCountStack.isEmpty())
                {
                    int goalsAdded = goalsAddedCountStack.poll();
                    removeAddedGoals(goalsAdded);
                    isGrowing = false;
                }
                else if (!isGrowing && !goalsConsumedCountStack.isEmpty())
                {
                    int goalsConsumed = goalsConsumedCountStack.poll();
                    replaceConsumedGoals(goalsConsumed);
                    isGrowing = true;
                }
            }
        }

        /**
         * Replaces the specified number of goals from the consumed goals stack back onto the wrapped stack.
         *
         * @param goalsConsumed The number of consumed goals to replace.
         */
        private void replaceConsumedGoals(int goalsConsumed)
        {
            for (int i = 0; i < goalsConsumed; i++)
            {
                BuiltInFunctor consumedGoal = consumedGoals.poll();

                goalStack.offer(consumedGoal);

                if (TRACE)
                {
                    /*trace.fine(indenter.generateTraceIndent() + "Backtracking, restore goal " +
                        consumedGoal + ".");*/
                }
            }
        }

        /**
         * Removes the specified number of added goals from the wrapped stack.
         *
         * @param goalsAdded The number of new goals to remove.
         */
        private void removeAddedGoals(int goalsAdded)
        {
            while (goalsAdded > 0)
            {
                BuiltInFunctor functor = goalStack.poll();
                goalsAdded -= (functor != null) ? 1 : 0;
            }
        }
    }

    /**
     * BindingSink provides a local view onto the global variable bindings established by the resolution process. It
     * allows variables bindings established by this state to be added, tracking the number added, so that when the
     * {@link #undo()} operation is called, the bindings can be reset to their state prior to this local view being
     * established. The {@link #undo()} operation frees variables (see {@link Variable#free()} as they are removed.
     */
    private class BindingSink implements Sink<Variable>
    {
        /** Holds the global stack of variable bindings for the resolution. */
        private final Queue<Variable> bindings;

        /**
         * Used to record how many variable bindings this state added, so that they can be removed upon backtracking.
         */
        private int numBindingsAdded;

        /**
         * Establishes a local binding sink on the binding stack.
         *
         * @param bindings The binding stack.
         */
        public BindingSink(Queue<Variable> bindings)
        {
            this.bindings = bindings;
        }

        /**
         * Adds a variable binding to the global binding stack, counting how many are added so that they can be removed
         * by the {@link #undo()} method.
         *
         * @param  variable The bound variable to add.
         *
         * @return <tt>true</tt> if the variable binding was added, <tt>false</tt> otherwise.
         */
        public boolean offer(Variable variable)
        {
            boolean result = bindings.offer(variable);
            numBindingsAdded += result ? 1 : 0;

            return result;
        }

        /** Removes and frees all bound variables added to this local view. */
        public void undo()
        {
            // Restore the variable bindings stack to where it was before this states operator was applied.
            while (numBindingsAdded > 0)
            {
                Variable variable = bindings.poll();

                if (variable != null)
                {
                    variable.free();

                    if (TRACE)
                    {
                        /*trace.fine(indenter.generateTraceIndent() + "Backtracking, unbind " +
                            variable.toString(interner, true, true));*/
                    }

                    numBindingsAdded--;
                }
            }
        }
    }
}
