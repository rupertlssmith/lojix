=== Cut

neck_cut or cut, ok to insert that correctly.
get_depth a little annoying, as needs to be part of the clause prefix instructions. also complicated the assignment
of permanent registers.

=== Call

Argument to call is built on the heap, or stack.

Call is implemented as a procedure that takes the argument, and turns it into a call, that is built args on heap, assign
argument registers, call.

Is it necessary to build a complete copy of the arguments on the heap, or can an argument register be set to point into
the existing structure?

=== Unifies

Create LHS as query parameters.
Create RHS as program parameters.
No call instruction, just run the 2 together.

OR

Implement as:

=(X, X).
\=(X, Y) :- \+(X = Y).

=== Disjunction

TryMe, RetryMe, TrustMe ?

Disjunction has arity/2, but want to treat a chain of disjunctions like a series of clauses. This means that each
disjunction cannot operate in isolation. Possibly look ahead at the next functor to see if it is also a disjunction?

a ; b

try_me a trust_me b

a ; b ; c

try_me a (look ahead and see next ;) retry_me b (look ahead and see no ;) trust_me c

Look ahead will be possible, as the disjunction has been parsed as a tree beneath a single ;

  ;
a   ;
  b   c

Does this complicate permanent register assignment?